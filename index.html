<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat Gateway</title>
  <style>
    body { font-family: "Segoe UI", Arial, sans-serif; margin:0; padding:0; display:flex; flex-direction:column; height:100vh; background:#ece5dd; }
    #header { background:#075e54; color:white; padding:15px; font-weight:bold; text-align:center; }
    #userConfig { background:#128c7e; padding:10px; display:flex; align-items:center; color:white; }
    #userInput { flex:1; padding:8px; border:none; border-radius:5px; }
    #saveUser { margin-left:10px; padding:8px 12px; border:none; background:#25d366; color:white; border-radius:5px; cursor:pointer; font-weight:bold; }
    #currentUser { margin-left:15px; font-weight:bold; }
    #messages { flex:1; overflow-y:auto; padding:15px; background:#ece5dd; display:flex; flex-direction:column; }
    .bubble { max-width:70%; padding:10px 15px; margin:5px; border-radius:20px; word-wrap:break-word; font-size:14px; white-space:pre-wrap; }
    .me { background:#dcf8c6; align-self:flex-end; }
    .you { background:#fff; border:1px solid #ccc; align-self:flex-start; }
    .meta { font-size:12px; color:#666; margin-top:6px; }
    .debug { display:none; background:#f7f7f7; color:#333; font-size:12px; border-left:3px solid #999; padding:8px; margin:6px; max-width:90%; white-space:pre-wrap; }
    #chatForm { display:flex; padding:10px; background:#f0f0f0; border-top:1px solid #ccc; align-items:center; }
    #messageInput { flex:1; padding:10px; border:none; border-radius:20px; outline:none; }
    #chatForm button { margin-left:10px; padding:10px 15px; border:none; background:#25d366; color:white; border-radius:50%; cursor:pointer; font-weight:bold; }
    #statusBar { font-size:13px; color:#444; margin-left:12px; }
    #smallNote { font-size:12px; color:#333; margin-left:12px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <div id="header">
    üëã Bem-vindo ao Chat Gateway ‚Äî configure seu UserID abaixo<br>
    üëã Welcome to Chat Gateway ‚Äî set your UserID below
  </div>

  <div id="userConfig">
    <input id="userInput" type="text" placeholder="Digite seu UserID / Enter your UserID" />
    <button id="saveUser">Salvar / Save</button>
    <span id="currentUser"></span>
  </div>

  <div id="messages"></div>

  <form id="chatForm">
    <input id="messageInput" type="text" placeholder="Digite sua mensagem... / Type your message..." autocomplete="off" />
    <button type="submit">‚û§</button>
    <div id="statusBar"></div>
  </form>

  <script>
    /**************************************************************************
     * CONFIGURA√á√ÉO - ajuste estes endpoints e reposit√≥rio raw se usar polling
     *
     * WEBHOOK_REQUEST: Make webhook que inicia o workflow (recebe client_payload)
     * WS_URL: endpoint WebSocket do seu backend (opcional). Se vazio, polling ser√° usado.
     * OWNER/REPO/BRANCH: usados para montar URL raw do GitHub status/<request_id>.json
     **************************************************************************/
    const WEBHOOK_REQUEST = "https://hook.us2.make.com/zdh65fxga487rr7a4rlnwspoefard0o5"; // Make: inicia job
    const WS_URL = ""; // ex: "wss://seu-backend.example.com/ws" - deixe vazio se n√£o usar WebSocket
    const OWNER = "seu-user-ou-org";      // ex: 'DanielSalvi82'
    const REPO = "seu-repo";              // ex: 'travel_Agent_API_call'
    const BRANCH = "main";                // branch onde est√° a pasta status
    const DEFAULT_POLL_INTERVAL_MS = 3000; // intervalo padr√£o entre polls
    const DEFAULT_MAX_ATTEMPTS = 60;       // limite de polls antes de timeout
    const CLIENT_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutos client-side timeout

    // UI helpers
    const messagesEl = document.getElementById('messages');
    const statusBar = document.getElementById('statusBar');

    function appendMessage(who, htmlContent) {
      const div = document.createElement('div');
      div.className = `bubble ${who}`;
      div.innerHTML = htmlContent;
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      return div;
    }

    function setStatus(text) {
      statusBar.textContent = text || '';
    }

    // Preserve userId
    let userId = localStorage.getItem('chat_user_id') || '';
    if (userId) {
      document.getElementById('userInput').value = userId;
      document.getElementById('currentUser').textContent = "Usu√°rio / User: " + userId;
    }
    document.getElementById('saveUser').addEventListener('click', () => {
      userId = document.getElementById('userInput').value.trim();
      if (userId) {
        localStorage.setItem('chat_user_id', userId);
        document.getElementById('currentUser').textContent = "Usu√°rio / User: " + userId;
      }
    });

    // Utilities
    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function normalizeBrokenText(s) {
      if (!s || typeof s !== 'string') return s;
      let t = s.replace(/\\"/g, '"').replace(/\\r/g, '\r').replace(/\\t/g, '\t');
      t = t.replace(/\n{3,}/g, '\n\n');
      t = t.trim();
      return t;
    }

    // Polling helpers (raw GitHub URL)
    function rawStatusUrl(requestId) {
      return `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/status/${encodeURIComponent(requestId)}.json`;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function fetchJsonNoCache(url) {
      const resp = await fetch(url, { cache: 'no-store' });
      if (!resp.ok) {
        const err = new Error(`HTTP ${resp.status}`);
        err.status = resp.status;
        throw err;
      }
      return resp.json();
    }

    function extractBestResponse(data) {
      if (!data) return null;
      if (data.response_text_clean) return data.response_text_clean;
      if (data.response_text_markdown) return data.response_text_markdown;
      if (data.response && data.response.text) return data.response.text;
      if (data.response_text) return data.response_text;
      if (data.response_text_html) return data.response_text_html;
      return null;
    }

    async function pollStatus(requestId, onUpdate, opts = {}) {
      const intervalMs = opts.intervalMs ?? DEFAULT_POLL_INTERVAL_MS;
      const maxAttempts = opts.maxAttempts ?? DEFAULT_MAX_ATTEMPTS;
      let attempts = 0;
      const url = rawStatusUrl(requestId);

      while (attempts < maxAttempts) {
        attempts++;
        try {
          const data = await fetchJsonNoCache(url);

          // respeitar poll_at se presente
          if (data.poll_at) {
            const pollAt = Date.parse(data.poll_at);
            if (!Number.isNaN(pollAt)) {
              const now = Date.now();
              if (pollAt > now) {
                const waitMs = Math.min(pollAt - now, intervalMs);
                await sleep(waitMs);
                continue;
              }
            }
          }

          if (data.status === 'completed') {
            const best = extractBestResponse(data);
            if (best) {
              onUpdate({ status: 'completed', payload: data, text: best });
              return { ok: true, data };
            }
            // completed mas sem texto: aguardar mais
          }

          onUpdate({ status: data.status ?? 'pending', payload: data, text: extractBestResponse(data) ?? null });

        } catch (err) {
          if (err.status === 404) {
            onUpdate({ status: 'not_found', error: 'status file not found yet' });
          } else {
            onUpdate({ status: 'error', error: err.message ?? String(err) });
          }
        }

        await sleep(intervalMs);
      }

      onUpdate({ status: 'timeout', error: 'max polling attempts reached' });
      return { ok: false, error: 'timeout' };
    }

    // WebSocket fallback (if WS_URL configured)
    let ws = null;
    const WS_RECONNECT_MS = 3000;

    function connectWebSocket() {
      if (!WS_URL) return;
      if (ws && ws.readyState === WebSocket.OPEN) return;

      setStatus('Conectando WebSocket...');
      try {
        ws = new WebSocket(WS_URL);

        ws.addEventListener('open', () => {
          setStatus('WebSocket conectado (push ativo)');
          if (userId) {
            try { ws.send(JSON.stringify({ type: 'identify', user_id: userId })); } catch(e) {}
          }
          const last = localStorage.getItem('last_request_id');
          if (last) {
            try { ws.send(JSON.stringify({ type: 'subscribe', request_id: last })); } catch(e) {}
          }
        });

        ws.addEventListener('message', (evt) => {
          try {
            const payload = JSON.parse(evt.data);
            // payload expected: { type: 'job_completed'|'job_update'|'job_timeout', request_id, response, ... }
            if (payload.type === 'job_completed') {
              clearClientTimeout();
              const finalText = payload.response || payload.response_text_clean || '';
              appendMessage('you', marked.parse(normalizeBrokenText(finalText)));
              setStatus('Finalizado (push) ‚Äî ' + (payload.request_id || ''));
              const saved = localStorage.getItem('last_request_id');
              if (saved && payload.request_id && saved === payload.request_id) localStorage.removeItem('last_request_id');
            } else if (payload.type === 'job_timeout') {
              clearClientTimeout();
              appendMessage('you', '<div class="meta">‚è±Ô∏è Tempo limite atingido no servidor</div>');
              setStatus('Timeout no servidor');
              localStorage.removeItem('last_request_id');
            } else if (payload.type === 'job_update') {
              setStatus('Atualiza√ß√£o: ' + (payload.status || 'processing'));
            } else if (payload.type === 'welcome') {
              if (payload.message) appendMessage('you', '<div class="meta">' + escapeHtml(payload.message) + '</div>');
            } else {
              if (payload.message) appendMessage('you', '<div class="meta">' + escapeHtml(payload.message) + '</div>');
            }
          } catch (e) {
            console.error('WS message parse error', e);
          }
        });

        ws.addEventListener('close', () => {
          setStatus('WebSocket desconectado. Tentando reconectar em ' + (WS_RECONNECT_MS/1000) + 's...');
          setTimeout(connectWebSocket, WS_RECONNECT_MS);
        });

        ws.addEventListener('error', (err) => {
          console.error('WS error', err);
          try { ws.close(); } catch(e) {}
        });
      } catch (err) {
        console.error('WS connect error', err);
        setTimeout(connectWebSocket, WS_RECONNECT_MS);
      }
    }

    // Client-side timeout handling
    let clientTimeoutHandle = null;
    function startClientTimeout(requestId) {
      clearClientTimeout();
      clientTimeoutHandle = setTimeout(() => {
        appendMessage('you', '<div class="meta">‚è±Ô∏è Tempo limite do cliente atingido. Tente novamente.</div>');
        setStatus('Timeout cliente');
        localStorage.removeItem('last_request_id');
      }, CLIENT_TIMEOUT_MS);
    }
    function clearClientTimeout() {
      if (clientTimeoutHandle) {
        clearTimeout(clientTimeoutHandle);
        clientTimeoutHandle = null;
      }
    }

    // Submit flow: send to Make webhook and then either rely on push or polling
    document.getElementById('chatForm').addEventListener('submit', async (ev) => {
      ev.preventDefault();
      const text = document.getElementById('messageInput').value.trim();
      if (!text) return;
      if (!userId) {
        alert('Defina seu UserID antes de enviar (campo acima).');
        return;
      }

      // show user message
      appendMessage('me', escapeHtml(text));
      document.getElementById('messageInput').value = '';

      // create request_id
      const requestId = `${new Date().toISOString().replace(/[:.]/g,'')}-${Math.floor(Math.random()*10000)}`;
      localStorage.setItem('last_request_id', requestId);

      // build client_payload expected by workflow
      const clientPayload = {
        request_id: requestId,
        prompt: JSON.stringify({ messages: [{ role: "user", content: text }] }),
        InputMessage: text,
        user_id: userId,
        needs_polling: true
      };

      setStatus('Enviando requisi√ß√£o ao workflow...');

      // POST to Make webhook (fire the workflow)
      try {
        const resp = await fetch(WEBHOOK_REQUEST, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(clientPayload)
        });
        if (!resp.ok) {
          appendMessage('you', `<div class="meta">Erro ao iniciar workflow: HTTP ${resp.status}</div>`);
          setStatus('Erro ao iniciar workflow');
          return;
        }
      } catch (err) {
        appendMessage('you', `<div class="meta">Erro de rede ao iniciar workflow: ${escapeHtml(String(err))}</div>`);
        setStatus('Erro de rede');
        return;
      }

      setStatus('Workflow iniciado. Aguardando resposta...');

      // If WS available, ensure connection and subscribe; otherwise start polling
      if (WS_URL) {
        connectWebSocket();
        // send subscribe message once connected (if already open)
        if (ws && ws.readyState === WebSocket.OPEN) {
          try { ws.send(JSON.stringify({ type: 'subscribe', request_id: requestId })); } catch(e) {}
        }
      }

      // start client timeout
      startClientTimeout(requestId);

      // Start polling as fallback (and also to show progress while waiting for push)
      (async () => {
        const result = await pollStatus(requestId, (update) => {
          if (update.status === 'not_found') {
            setStatus('Aguardando cria√ß√£o do status...');
            return;
          }
          if (update.status === 'pending') {
            const preview = update.text ? (update.text.length > 300 ? update.text.slice(0,300) + '‚Ä¶' : update.text) : 'Processando‚Ä¶';
            setStatus('Processando (polling)‚Ä¶');
            // show a small preview if available
            if (update.text) {
              // replace last preview bubble if exists
              const lastPreview = document.getElementById('preview-' + requestId);
              if (lastPreview) lastPreview.remove();
              const el = appendMessage('you', '<div id="preview-' + requestId + '" class="meta">Preview: ' + escapeHtml(preview) + '</div>');
            }
            return;
          }
          if (update.status === 'completed') {
            clearClientTimeout();
            const payload = update.payload || {};
            // prefer HTML if present
            if (payload.response_text_html) {
              appendMessage('you', payload.response_text_html);
            } else {
              const text = update.text || '';
              appendMessage('you', marked.parse(normalizeBrokenText(text)));
            }
            setStatus('Finalizado (polling) ‚Äî ' + requestId);
            localStorage.removeItem('last_request_id');
            return;
          }
          if (update.status === 'error') {
            appendMessage('you', `<div class="meta">Erro: ${escapeHtml(update.error || 'unknown')}</div>`);
            setStatus('Erro no polling');
            return;
          }
          if (update.status === 'timeout') {
            appendMessage('you', '<div class="meta">‚è±Ô∏è Tempo esgotado aguardando resposta (polling).</div>');
            setStatus('Timeout polling');
            return;
          }
        }, { intervalMs: DEFAULT_POLL_INTERVAL_MS, maxAttempts: DEFAULT_MAX_ATTEMPTS });

        if (!result.ok) {
          // if polling timed out and WS is available, keep waiting for push; otherwise show final timeout
          if (!WS_URL) {
            clearClientTimeout();
            appendMessage('you', '<div class="meta">Nenhuma resposta recebida. Tente novamente mais tarde.</div>');
            setStatus('Sem resposta');
            localStorage.removeItem('last_request_id');
          } else {
            setStatus('Aguardando push via WebSocket (se dispon√≠vel)...');
          }
        }
      })();
    });

    // Inicializar WebSocket se configurado
    if (WS_URL) connectWebSocket();

    // Se houver um last_request_id salvo ao carregar a p√°gina, retomar polling/subscri√ß√£o
    (function resumePending() {
      const last = localStorage.getItem('last_request_id');
      if (!last) return;
      appendMessage('you', `<div class="meta">Retomando requisi√ß√£o pendente: ${escapeHtml(last)}</div>`);
      setStatus('Retomando requisi√ß√£o pendente...');
      // subscribe via WS if available
      if (WS_URL) {
        connectWebSocket();
        if (ws && ws.readyState === WebSocket.OPEN) {
          try { ws.send(JSON.stringify({ type: 'subscribe', request_id: last })); } catch(e) {}
        }
      }
      // start polling as fallback
      startClientTimeout(last);
      (async () => {
        await pollStatus(last, (update) => {
          if (update.status === 'completed') {
            clearClientTimeout();
            const payload = update.payload || {};
            if (payload.response_text_html) {
              appendMessage('you', payload.response_text_html);
            } else {
              appendMessage('you', marked.parse(normalizeBrokenText(update.text || '')));
            }
            setStatus('Finalizado (retomado) ‚Äî ' + last);
            localStorage.removeItem('last_request_id');
          } else {
            setStatus('Retomando: ' + (update.status || 'pending'));
          }
        }, { intervalMs: DEFAULT_POLL_INTERVAL_MS, maxAttempts: DEFAULT_MAX_ATTEMPTS });
      })();
    })();
  </script>
</body>
</html>
