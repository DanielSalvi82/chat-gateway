<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat Gateway</title>
  <style>
    body { font-family: "Segoe UI", Arial, sans-serif; margin:0; padding:0; display:flex; flex-direction:column; height:100vh; background:#ece5dd; }
    #header { background:#075e54; color:white; padding:15px; font-weight:bold; text-align:center; }
    #userConfig { background:#128c7e; padding:10px; display:flex; align-items:center; color:white; }
    #userInput { flex:1; padding:8px; border:none; border-radius:5px; }
    #saveUser { margin-left:10px; padding:8px 12px; border:none; background:#25d366; color:white; border-radius:5px; cursor:pointer; font-weight:bold; }
    #currentUser { margin-left:15px; font-weight:bold; }
    #messages { flex:1; overflow-y:auto; padding:15px; background:#ece5dd; display:flex; flex-direction:column; }
    .bubble { max-width:70%; padding:10px 15px; margin:5px; border-radius:20px; word-wrap:break-word; font-size:14px; white-space:pre-wrap; }
    .me { background:#dcf8c6; align-self:flex-end; }
    .you { background:#fff; border:1px solid #ccc; align-self:flex-start; }
    .meta { font-size:12px; color:#666; margin-top:6px; }
    .debug { display:none; background:#f7f7f7; color:#333; font-size:12px; border-left:3px solid #999; padding:8px; margin:6px; max-width:90%; white-space:pre-wrap; }
    #chatForm { display:flex; padding:10px; background:#f0f0f0; border-top:1px solid #ccc; align-items:center; }
    #messageInput { flex:1; padding:10px; border:none; border-radius:20px; outline:none; }
    #chatForm button { margin-left:10px; padding:10px 15px; border:none; background:#25d366; color:white; border-radius:50%; cursor:pointer; font-weight:bold; }
    #statusBar { font-size:13px; color:#444; margin-left:12px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <div id="header">
    üëã Bem-vindo ao Chat Gateway ‚Äî configure seu UserID abaixo<br>
    üëã Welcome to Chat Gateway ‚Äî set your UserID below
  </div>

  <div id="userConfig">
    <input id="userInput" type="text" placeholder="Digite seu UserID / Enter your UserID" />
    <button id="saveUser" type="button">Salvar / Save</button>
    <span id="currentUser"></span>
  </div>

  <div id="messages"></div>

  <form id="chatForm" autocomplete="off">
    <input id="messageInput" name="message" type="text" placeholder="Digite sua mensagem... / Type your message..." />
    <button id="sendBtn" type="submit">‚û§</button>
    <div id="statusBar"></div>
  </form>

  <script>
    // CONFIGURA√á√ÉO - ajuste estes endpoints
    const WEBHOOK_REQUEST = "https://hook.us2.make.com/zdh65fxga487rr7a4rlnwspoefard0o5"; // Make: inicia job
    const OWNER = 'seu-user-ou-org';      // ex: 'DanielSalvi82'
    const REPO = 'seu-repo';              // ex: 'travel_Agent_API_call'
    const BRANCH = 'main';                // branch onde est√° a pasta status
    const DEFAULT_POLL_INTERVAL_MS = 3000; // intervalo padr√£o entre polls
    const DEFAULT_MAX_ATTEMPTS = 60;       // limite de polls antes de timeout
    const CLIENT_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutos client-side timeout

    // UI helpers
    const $ = id => document.getElementById(id);
    const messagesEl = $('messages');
    const statusBar = $('statusBar');

    function appendMessage(who, htmlContent) {
      const div = document.createElement('div');
      div.className = `bubble ${who}`;
      div.innerHTML = htmlContent;
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      return div;
    }

    function setStatus(text) {
      statusBar.textContent = text || '';
    }

    function escapeHtml(s) {
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function normalizeBrokenText(s) {
      if (!s || typeof s !== 'string') return s;
      let t = s.replace(/\\"/g, '"').replace(/\\r/g, '\r').replace(/\\t/g, '\t');
      t = t.replace(/\n{3,}/g, '\n\n');
      t = t.trim();
      return t;
    }

    // Preserve userId
    let userId = localStorage.getItem('chat_user_id') || '';
    if (userId) {
      $('userInput').value = userId;
      $('currentUser').textContent = "Usu√°rio / User: " + userId;
    }
    $('saveUser').addEventListener('click', () => {
      userId = $('userInput').value.trim();
      if (userId) {
        localStorage.setItem('chat_user_id', userId);
        $('currentUser').textContent = "Usu√°rio / User: " + userId;
      }
    });

    // Polling helpers (raw GitHub URL)
    function rawStatusUrl(requestId) {
      return `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/status/${encodeURIComponent(requestId)}.json`;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function fetchJsonNoCache(url) {
      const resp = await fetch(url, { cache: 'no-store' });
      if (!resp.ok) {
        const err = new Error(`HTTP ${resp.status}`);
        err.status = resp.status;
        throw err;
      }
      return resp.json();
    }

    function extractBestResponse(data) {
      if (!data) return null;
      if (data.response_text_clean) return data.response_text_clean;
      if (data.response_text_markdown) return data.response_text_markdown;
      if (data.response && data.response.text) return data.response.text;
      if (data.response_text) return data.response_text;
      if (data.response_text_html) return data.response_text_html;
      return null;
    }

    async function pollStatus(requestId, onUpdate, opts = {}) {
      const intervalMs = opts.intervalMs ?? DEFAULT_POLL_INTERVAL_MS;
      const maxAttempts = opts.maxAttempts ?? DEFAULT_MAX_ATTEMPTS;
      let attempts = 0;
      const url = rawStatusUrl(requestId);

      while (attempts < maxAttempts) {
        attempts++;
        try {
          const data = await fetchJsonNoCache(url);

          // Se poll_at estiver presente, aguardar at√© o timestamp sugerido
          if (data.poll_at) {
            const pollAt = Date.parse(data.poll_at);
            if (!Number.isNaN(pollAt)) {
              const now = Date.now();
              if (pollAt > now) {
                const waitMs = Math.min(pollAt - now, intervalMs);
                await sleep(waitMs);
                continue; // re-tentar ap√≥s aguardar
              }
            }
          }

          // Se status completed e tem resposta, retornar
          if (data.status === 'completed') {
            const best = extractBestResponse(data);
            if (best) {
              onUpdate({ status: 'completed', payload: data, text: best });
              return { ok: true, data };
            }
            // se completed mas sem texto, ainda aguardar mais um pouco
          }

          // Se status diferente ou sem resposta ainda, chamar onUpdate com progresso parcial
          onUpdate({ status: data.status ?? 'pending', payload: data, text: extractBestResponse(data) ?? null });

        } catch (err) {
          // 404 significa que o arquivo ainda n√£o foi criado; apenas log e continuar
          if (err.status === 404) {
            onUpdate({ status: 'not_found', error: 'status file not found yet' });
          } else {
            onUpdate({ status: 'error', error: err.message ?? String(err) });
          }
        }

        // aguardar antes do pr√≥ximo poll
        await sleep(intervalMs);
      }

      // timeout
      onUpdate({ status: 'timeout', error: 'max polling attempts reached' });
      return { ok: false, error: 'timeout' };
    }

    // Decision function: should we trigger the remote Fireworks proxy?
    // IMPORTANT: this function decides whether the flow ends internally (no proxy, no polling)
    // or triggers the proxy (proxy + polling). Adjust logic as needed.
    function needsRemoteProxy(text) {
      if (!text) return false;
      const t = text.trim();
      // Example rules (customize to your needs):
      // - explicit command prefix "/remote" triggers proxy
      // - very long messages trigger proxy
      // - otherwise, process locally
      if (t.startsWith('/remote')) return true;
      if (t.length > 300) return true;
      return false;
    }

    // Client-side timeout handling
    let clientTimeoutHandle = null;
    function startClientTimeout(requestId) {
      clearClientTimeout();
      clientTimeoutHandle = setTimeout(() => {
        appendMessage('you', '<div class="meta">‚è±Ô∏è Tempo limite do cliente atingido. Tente novamente.</div>');
        setStatus('Timeout cliente');
        localStorage.removeItem('last_request_id');
      }, CLIENT_TIMEOUT_MS);
    }
    function clearClientTimeout() {
      if (clientTimeoutHandle) {
        clearTimeout(clientTimeoutHandle);
        clientTimeoutHandle = null;
      }
    }

    // Attach handlers once and robustly
    (function initHandlers() {
      const form = $('chatForm');
      const input = $('messageInput');
      const sendBtn = $('sendBtn');

      if (!form || !input || !sendBtn) {
        console.error('Elementos da UI ausentes');
        return;
      }

      async function handleSubmit(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        const text = input.value.trim();
        if (!text) return;
        if (!userId) {
          alert('Defina seu UserID antes de enviar (campo acima).');
          return;
        }

        // show user message
        appendMessage('me', escapeHtml(text));
        input.value = '';

        // Decide whether to process locally or call proxy
        if (!needsRemoteProxy(text)) {
          // Process locally (Cen√°rio 1) ‚Äî no proxy call, no polling
          setStatus('Processando localmente (sem proxy)...');
          try {
            // Replace this with your actual local processing logic
            const localResult = 'Resposta processada localmente: ' + text;
            appendMessage('you', escapeHtml(localResult));
            setStatus('Finalizado localmente (sem polling)');
          } catch (err) {
            appendMessage('you', `<div class="meta">Erro no processamento local: ${escapeHtml(String(err))}</div>`);
            setStatus('Erro local');
          }
          return;
        }

        // Cen√°rio 2: trigger Fireworks proxy and do polling
        const requestId = `${new Date().toISOString().replace(/[:.]/g,'')}-${Math.floor(Math.random()*10000)}`;
        localStorage.setItem('last_request_id', requestId);

        const clientPayload = {
          request_id: requestId,
          prompt: JSON.stringify({ messages: [{ role: "user", content: text }] }),
          InputMessage: text,
          user_id: userId,
          needs_polling: "true"
        };

        setStatus('Enviando requisi√ß√£o ao workflow...');

        // POST to Make webhook (fire the workflow)
        try {
          const resp = await fetch(WEBHOOK_REQUEST, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(clientPayload)
          });
          if (!resp.ok) {
            appendMessage('you', `<div class="meta">Erro ao iniciar workflow: HTTP ${resp.status}</div>`);
            setStatus('Erro ao iniciar workflow');
            return;
          }
        } catch (err) {
          appendMessage('you', `<div class="meta">Erro de rede ao iniciar workflow: ${escapeHtml(String(err))}</div>`);
          setStatus('Erro de rede');
          return;
        }

        setStatus('Workflow iniciado. Aguardando resposta...');

        // start client timeout
        startClientTimeout(requestId);

        // Start polling for the status file created by the proxy
        (async () => {
          const result = await pollStatus(requestId, (update) => {
            if (update.status === 'not_found') {
              setStatus('Aguardando cria√ß√£o do status...');
              return;
            }
            if (update.status === 'pending') {
              const preview = update.text ? (update.text.length > 300 ? update.text.slice(0,300) + '‚Ä¶' : update.text) : 'Processando‚Ä¶';
              setStatus('Processando (polling)‚Ä¶');
              if (update.text) {
                const lastPreview = document.getElementById('preview-' + requestId);
                if (lastPreview) lastPreview.remove();
                appendMessage('you', '<div id="preview-' + requestId + '" class="meta">Preview: ' + escapeHtml(preview) + '</div>');
              }
              return;
            }
            if (update.status === 'completed') {
              clearClientTimeout();
              const payload = update.payload || {};
              if (payload.response_text_html) {
                appendMessage('you', payload.response_text_html);
              } else {
                const text = update.text || '';
                appendMessage('you', marked.parse(normalizeBrokenText(text)));
              }
              setStatus('Finalizado (polling) ‚Äî ' + requestId);
              localStorage.removeItem('last_request_id');
              return;
            }
            if (update.status === 'error') {
              appendMessage('you', `<div class="meta">Erro: ${escapeHtml(update.error || 'unknown')}</div>`);
              setStatus('Erro no polling');
              return;
            }
            if (update.status === 'timeout') {
              appendMessage('you', '<div class="meta">‚è±Ô∏è Tempo esgotado aguardando resposta (polling).</div>');
              setStatus('Timeout polling');
              return;
            }
          }, { intervalMs: DEFAULT_POLL_INTERVAL_MS, maxAttempts: DEFAULT_MAX_ATTEMPTS });

          if (!result.ok) {
            clearClientTimeout();
            appendMessage('you', '<div class="meta">üîÑ Nenhuma resposta recebida. Tente novamente mais tarde.</div>');
            setStatus('Sem resposta');
            localStorage.removeItem('last_request_id');
          }
        })();
      }

      // Ensure single attachment of handlers
      form.addEventListener('submit', handleSubmit);
      $('sendBtn').addEventListener('click', (ev) => {
        // click should trigger submit; prevent double handling
        // let the form submit handler handle the logic
      });

      // Allow Enter to submit while preventing accidental form autocomplete
      $('messageInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          form.requestSubmit();
        }
      });

      // focus input for convenience
      try { $('messageInput').focus(); } catch(e){}
    })();

    // If there's a pending request on load, resume polling (only relevant if proxy was triggered)
    (function resumePending() {
      const last = localStorage.getItem('last_request_id');
      if (!last) return;
      appendMessage('you', `<div class="meta">Retomando requisi√ß√£o pendente: ${escapeHtml(last)}</div>`);
      setStatus('Retomando requisi√ß√£o pendente...');
      (async () => {
        await pollStatus(last, (update) => {
          if (update.status === 'completed') {
            const payload = update.payload || {};
            const textResp = update.text || (payload.response && payload.response.text) || '';
            appendMessage('you', marked.parse(normalizeBrokenText(textResp)));
            setStatus('Finalizado (retomado) ‚Äî ' + last);
            localStorage.removeItem('last_request_id');
          } else {
            setStatus('Retomando: ' + (update.status || 'pending'));
          }
        }, { intervalMs: DEFAULT_POLL_INTERVAL_MS, maxAttempts: DEFAULT_MAX_ATTEMPTS });
      })();
    })();
  </script>
</body>
</html>
